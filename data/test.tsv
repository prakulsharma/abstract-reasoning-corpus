Filename	Reflections	Pixel/Object Changes	Helper Functions	Program Instructions
508bd3b6.png	This task involves extrapolating a pattern that describes a ball bouncing off a wall.	Two new lines of the value '3' are filled. One of the lines is a linear extrapolation of the '8' line to the '2' wall. The other one is a reflected line off the '2' wall. 	get_objects can be used to identify the '2' wall and the '8' line. fill_between_coords can be used to draw the two '3' lines.	1. Obtain all objects using get_objects. 2. Identify the starting and ending position of the extrapolation '3' line, from the end of the '8' line to the '2' wall. 3. Fill in the extrapolation line using fill_between_coords. 4. Identify the starting and ending position of the reflected '3' line, from the end of the newly added line to the grid border. 5. Fill in the reflected line using fill_between_coords.
1caeab9d.png	The task involves identifying coloured objects within the grid and moving them vertically so they align with the row that contains the blue object. The size and colour of the objects remain unchanged during this transformation.	The number of objects, their colours, and their sizes remain the same between the input and output. However, their positions change. In particular, all objects are moved so that they lie along a single row in the output grid. The relative ordering of the objects from left to right is also preserved during this movement.	get_objects can be used to retrieve the list of objects in the input grid.  fill_object can be used to add these objects back to a new grid at the appropriate positions.	1. Use get_objects to retrieve a list of the objects in the input grid. 2. Retrieve the top-left coordinate of the blue object.  3. Create a new empty grid of the same size as the input grid.  4. Iterate over the objects retrieved in step 1, for each object: 5. Retrieve the top-left coordinate of the object.  6. Modify the row coordinate of the top-left coordinate so that it corresponds to the row coordinate of the top-left coordinate of the blue object.  7. Use fill_object to add the object to the new grid at the modified top-left coordinate. 8. Return the new grid.
d4f3cd78.png	The task requires filling a hollow grey square with light blue pixels, and extending a line in light blue pixels from the open end of the square to the edge of the grid in the direction of the opening.	The input grid features a hollow square made up of grey pixels with one side having an opening. The output involves filling the inner area of this square with light blue pixels. Additionally, from the opening of the grey square, a continuous straight line of light blue pixels is drawn to the nearest edge of the grid.	fill_value: To change the color of the pixels inside the hollow square and to draw the line extending from the opening.	1. Identify the coordinates of the grey pixels forming the square.\n2. Locate the opening in the square by finding where the continuous line of grey pixels is interrupted.\n3. Fill the inside of the hollow grey square with light blue pixels.\n4. Use the location of the opening to draw a straight line of light blue pixels from the opening to the edge of the grid in the direction it opens, up till the grid's boundaries.
67385a82.png	This task involves identifying pixels that are connected to other pixels in 4 directions.	Pixels that are neighbouring other pixels in the top, bottom, left, right position are recolored to '8'.	fill_value can be used to recolor the pixels.	1. For each pixel, check if there is another pixel at the top, bottom, left and right of it. 2. If the condition is true, color the pixel with fill_value.
cf98881b.png	The task involves creating a composite grid from three separate grids, where the color of pixels in the first grid is modified based on the color of the corresponding pixels in the second and third grids, using red lines as dividers.	The input grid is divided into three sections by red lines. The pixels from the first section are checked against the corresponding pixels in the second and third sections. If a black pixel from the first section corresponds to a pink pixel in the second section, it changes to pink in the output. Similarly, if a black (not yet turned pink) pixel in the resulting grid corresponds to a blue pixel in the third section, it changes to blue in the output.	get_pixel_coords: Not necessary if we iterate through each grid by position.\nreplace: To change the color of pixels in the new grid based on the color of corresponding pixels in the second and third grids.\nchange_object_color: Changes the color of an object to a specified value.	1. Separate the input grid into three smaller grids based on the red lines.\n2. Create a new grid with the same dimensions as one of the smaller grids to store the output, copy the left-most smaller grid to the new grid.\n3. For each black pixel in the first grid:\n   - Check the corresponding pixel in the second grid. If it's pink, change the color in the new grid to pink.\n   - Then, check the corresponding pixel in the third grid. If it's blue, change the color in the new grid to blue.\n4. The new grid now reflects the composite of all three grids following the color priority rules: black can change to pink or blue, and pink can change to blue.\n5. This resulting grid is the output.
6150a2bd.png	The task involves rotating the input grid by 180 degrees.	The pixels are the 180 degree rotated version of the input grid.	rotate_clockwise can be used to rotate the grid by 180 degrees.	1. Use rotate_clockwise to rotate the input grid by 180 degrees.
8be77c9e.png	The task involves combining the input grid with its mirror image about the bottom edge.	The height of the input grid is doubled. The lower half of the output grid is the vertically mirrored version of the input grid.	vertical_flip can be used to obtain a mirrored image of the input grid. combine_object can be used to combine the mirrored grid with the original grid 	1. get the mirrored image of the input grid. 2. combine the mirrored image with the input grid to get the output grid.
d364b489.png	The task involves adding a set of red, beige, magenta, and grey pixels around each blue pixel to its top, left, right, and bottom.	For each blue pixel present in the input grid, four new pixels are added in cardinal directions: red above, beige to the left, magenta to the right, and grey below the blue pixel. The blue pixel retains its original position, and the added pixels occupy the immediately adjacent cells, assuming they fall within the grid boundaries.	get_pixel_coords: Used to find the coordinates of the colored pixels and the 2x2 block within the grid.\nfill_value: Employed to change the original position of the moved pixel to black.	- Use `get_pixel_coords` to locate all blue pixels on the grid.\n- For each blue pixel found, add the specified colors around it as follows:\n  - Add a red pixel above the blue pixel.\n  - Add a beige pixel to the left of the blue pixel.\n  - Add a magenta pixel to the right of the blue pixel.\n  - Add a grey pixel below the blue pixel.\n- Ensure that the addition of new pixels does not exceed the grid boundaries.\n- Return the modified grid as the final output.
44d8ac46.png	The task involves identifying objects that contain a square hole, and filling '2' inside the hole. Objects that contains non-square holes, such as rectangles, are left the same.	There are no creation or destruction of objects. The objects maintain their shape but those that contain a square hole are filled with pixel value of '2'. 	get_objects can be used to obtain all the objects. fill_rect can be used to fill in the square holes.	1. Get all objects using the get_objects function. 2. For each object, check if the shape of its hole is a square. 3. Fill square holes with '2'. Keep non-square holes the same.   
40853293.png	The problem requires identifying pairs of pixels of the same color and drawing lines to connect them. If the lines are horizontal, they extend from left to right; if vertical, from top to bottom. When these lines intersect, the intersection assumes the color of the vertical line.	Important objects: Pairs of pixels of the same color. Changes: Drawing lines to connect pairs and altering the color of intersections according to the vertical line's color.	get_pixel_coords(grid): To get the coordinates of colored pixels. fill_row(grid, row_num, value, start_col, end_col): To fill in the horizontal line. fill_col(grid, col_num, value, start_row, end_row): To fill in the vertical line. fill_value(grid, pos, value): To change the color of an intersection point.	1. Use get_pixel_coords(grid) to find all the colored pixels and their coordinates. 2. Group these coordinates by color to identify pairs. 3. For each pair:  1. If they are in the same row, use fill_row() to draw a horizontal line connecting them.  2. If they are in the same column, use fill_col() to draw a vertical line connecting them. 4. After drawing all lines, check for intersections:  1. If a horizontal line and a vertical line intersect, use fill_value() to color the intersection point with the color of the vertical line's pixels.
d5d6de2d.png	The task transforms hollow red boxes in the input grid into filled green boxes with black borders in the output grid.	In the input, hollow red boxes are identified by their red borders. In the output, the inside of these boxes is filled with green pixels, and the red border pixels are turned black. The size and position of the boxes remain unchanged.	get_pixel_coords: Not necessary if we identify box borders through direct iteration.\nempty_grid: To initialize an empty output grid matching the input grid size.\nfill_rect: To fill the interior of the detected hollow red boxes with green.\nfill_value: To change the red border pixels to black.	1. Identify the red borders of the hollow boxes and their coordinates using a method of detecting connected red pixels that form a square or rectangular shape.\n2. Create an `empty_grid` with the same dimensions as the input grid.\n3. For each detected red border, fill the interior area with green pixels using the `fill_rect` function, ensuring the interior coordinates are correctly identified.\n4. Change the red border pixels to black using the `fill_value` function on the detected border coordinates.\n5. The final output will show green-filled boxes with black borders, where the original red boxes were in the input.
681b3aeb.png	The task involves completing a square using the two shapes provided.	A 3x3 grid is that contains the two object from the input is returned. The two objects has to fit together perfectly such that is becomes a 3x3 square.	get_objects can be used to obtain the two objects. empty_grid can be used to obtain the 3x3 grid. fill_object can be used to fill the grid with the object.	1. Use get_objects to get the two objects. 2. Use empty grid to create the 3x3 output grid. 3. Figure out the possible solution to fit the 2 objects together to obtain a perfect 3x3 square. 4. Use fill_object to fill the objects to the grid using the found solution.
67e8384a.png	The task involves mirroring the input grid horizontally and vertically such that the output grid is symmetric.	The output grid is doubled in width and height of the input grid. The pattern of the input grid are mirrored such that the output grid is vertically and horizontally symmetric.	horizontal_flip and vertical_flip can be used to generate the mirrored image. empty_grid can be used to create the output grid.	1. Use empty_grid to create the output grid that is doubled in width and height of the input grid. 2. Use horizontal_flip to generate a flipped pattern of the input. 3. Place the flipped pattern on the right of the original pattern. 4. Flip the resulting pattern again using vertical_flip. 5. Place the flipped pattern under the previous pattern.
95990924.png	The task involves coloring the outer pixels on the corner along the diagonal of the gray blocks.  	The objects are the gray blocks. The top right pixel is colored as red, bottom right is yellow, bottom left is green and top left is blue.	get_objects can be used to get the gray objects. fill_value can be used to color the pixels on the corners.	1. obtain the object 2. fill the pixel on the corners with the responding colors.
2c608aff.png	The logic in this ARC task involves identifying a primary coloured square or rectangle and any other non-background coloured pixels. If any of these additional pixels share a horizontal or vertical line with the primary shape, a strip is drawn from that pixel to the closest edge of the primary shape in the corresponding direction.	The main objects are the primary square or rectangular objects and the non-background coloured pixels. Strips are drawn from these pixels to the primary object if they align horizontally or vertically with the object.	get_objects(grid, by_color=False) - to identify the primary object and other coloured pixels. get_pixel_coords(grid) - to get the coordinates of the non-background coloured pixels. fill_row(grid, row_num, value, start_col, end_col) - to fill in rows for strips. fill_col(grid, col_num, value, start_row, end_row) - to fill in columns for strips.	1. Use get_objects(grid, by_color=False) to identify the primary square or rectangle object in the input grid. 2. Use get_pixel_coords(grid) to get coordinates of all non-background colored pixels. 3. For each non-background pixel identified:         1. Check if it shares a row or column with the primary object.         2. If it shares a row, use fill_row(grid, row_num, value, start_col, end_col) to draw a horizontal strip from that pixel to the edge of the primary object, where value is the pixel's color.         3. If it shares a column, use fill_col(grid, col_num, value, start_row, end_row) to draw a vertical strip from that pixel to the edge of the primary object, where value is the pixel's color. 4. Ensure the strip is only drawn to the edge of the primary shape and does not extend beyond it.
2dee498d.png	The task involves recognizing a repeating pattern of colours that forms a square in the input grid. The solution requires identifying the dimensions of this square based on the number of rows in the grid and then cropping this square pattern out of the grid from one end.	The main object is the repeating colour pattern that forms a square. We count the number of rows to determine the square's dimension. Then, we crop the grid to obtain the square with the repeating pattern.	get_objects(grid, by_row=True) - to identify the rows and analyze the repeating pattern. crop_grid(grid, tl, br) - to crop the grid into the square of interest.	1. Use get_objects(grid, by_row=True) to identify the number of rows in the grid and to analyze the repeating pattern. 2. Determine the dimensions of the square pattern (which will be the same as the number of rows). 3. Use crop_grid(grid, tl, br) to crop a square from the grid starting from one end.
62c24649.png	The task involves mirroring the input grid horizontally and vertically such that the output grid is symmetric.	The output grid is doubled in width and height of the input grid. The pattern of the input grid are mirrored such that the output grid is vertically and horizontally symmetric.	horizontal_flip and vertical_flip can be used to generate the mirrored image. empty_grid can be used to create the output grid.	1. Use empty_grid to create the output grid that is doubled in width and height of the input grid. 2. Use horizontal_flip to generate a flipped pattern of the input. 3. Place the flipped pattern on the right of the original pattern. 4. Flip the resulting pattern again using vertical_flip. 5. Place the flipped pattern under the previous pattern.
4347f46a.png	The task requires the identification of distinct colored objects within the input grid and the modification of these objects so that only their boundaries retain the original color while the interiors are filled with black pixels. Essentially, it is the process of creating an outline of each object	 Important objects: Colored rectangles within the input grid. Changes: The interior of each colored object is changed to black, leaving only the boundary in the original color.	get_objects(grid, by_color=True): To identify distinct colored objects within the grid. fill_rect(grid, tl, br, value): To fill the interior of the objects with black pixels. get_object_color(obj): To obtain the color of the object for the boundary. fill_value(grid, pos, value): To fill the boundary with the original object color.	1. Use get_objects(grid, by_color=True) on the input grid to obtain a list of objects, including their top-left and bottom-right coordinates and their color. 2. For each object identified:  1. Store the color of the object using get_object_color(obj).  2. Use fill_rect(grid, tl, br, value) with black to fill the entire object area.  3. Restore the object's boundary by using fill_value(grid, pos, value) with the stored color
6430c8c4.png	The task involves identifying pixels that are missing at the same location in two objects.	The size of the output grid is the square of the top half for the input grid. The pixels of the output grid depends on the two object in the input grid. If a pixel is missing at the same position for both objects, the pixel of the same position at the output grid is colored as '3'.	get_objects can be used to get the two objects. combine_object can be used to check for common missing pixels. empty_grid can be used to create the output grid. fill_value can be used to fill the pixels of the output grid.	1. Use get_objects to get the two objects. 2. Create the output grid using empty_grid. 3. Use combine_objects to overlay the two objects. 4. For each pixel of the output grid, if the pixel of the same location is missing at the combined object, use fill_value to fill the pixel at the output with '3'.
a8d7556c.png	The task involves identifying any square or rectangle formed by more than one pixel in length and width each and coloring them red.	The objects are squares or rectangles that have both dimensions having more than one pixel. The objects are then changed into red color.	get_objects can be used to find out objects that form either a square or a rectangle. fill_object can be used to color the objects red.	1. obtain the objects 2. color them red
de1cd16c.png	The task is to identify the color that appears the least in the grid, then determine which color surrounds these least frequent pixels the most, and output a single pixel of this most surrounding color.	The grid is examined to count the pixels of each color. The color with the lowest count is determined, and then the surrounding pixels of this least frequent color are counted by color. The color that most frequently surrounds the least frequent color is identified, and the output is a single pixel of this color.	get_pixel_coords: To identify all the pixel colors and their coordinates.\nempty_grid and fill_value: To create a new grid or place the single pixel of the resulting color.	1. Use `get_pixel_coords` to obtain a dictionary of pixel colors and their coordinates.\n2. Count the number of pixels of each color to identify the color that appears the least.\n3. For the least frequent color, examine the surrounding pixels to count the frequency of each surrounding color.\n4. Identify which color surrounds the least frequent color the most.\n5. Create a new grid with a single pixel of the most surrounding color.
48d8fb45.png	This task involves identifying an object that is marked by a pixel of '5' on top. 	The output grid contains only the object that has a pixel of '5' on top. The pixel of '5' is not returned. The color and shape of the object remains the same.	get_objects can be used to obtain the objects. get_object_color can be used to identify the '5' pixel object.	1. Get all objects using get_objects. 2. Identify the position of the '5' pixel object. 3. Identify the object that is directly below and touching the '5' pixel. 4. Return a grid that contains only the object.
1fad071e.png	The task requires identifying all the 2x2 squares of blue pixels in the input grid. The output is a horizontal line of five cells, where the number of blue cells corresponds to the number of 2x2 blue squares identified in the input.	The main object in this task is the number of 2x2 squares composed entirely of blue pixels. Counting the number of 2x2 blue squares to determine the number of blue cells in the output.	get_objects(): To detect and count the 2x2 squares of blue pixels. fill_value(): To create the horizontal line of cells for the output, fill the appropriate number of cells with blue colour based on the count. empty_grid: To create the horizontal strip that will be used as the output	1. Use get_objects(grid, by_color=False) to detect all objects. 2. Iterate through each object to check if it is a 2x2 square of blue pixels. This can be determined by checking the size of the object (size) and the color (get_object_color()). 3. Count the number of 2x2 blue squares. 4. Create a horizontal line of five cells using empty_grid(1, 5) to represent the output line. 5. Using fill_value (), fill the number of cells from the left of this line with blue, equivalent to the number of 2x2 squares counted. The rest of the cells remain black.
54d9e175.png	This task involves filling each region of the input grid with a color uniquely mapped to the color of the pixel at the center.	Each region that is separated by the '5' grid is filled with a new color. This color is uniquely mapped to the color at the center of each region. The pairs are '1' -> '6', '2' -> 7, '3' -> '8', '4' -> '9'	fill_rect can be used to fill the colors of each region.	1. For each region, identify the color at the center. 2. Identify the new color for each region. 3. Fill each region with the new color using fill_rect.
d4469b4b.png	The task involves filling a 3x3 grid with grey pixels in specific patterns based on the color of non-black pixels in the input.	For each input grid, non-black colored pixels (red, blue, or green) determine the placement of grey pixels in a new 3x3 grid. Red pixels correspond to a 'T' shape, blue to a '+' shape, and green to a mirrored 'L' shape within this 3x3 grid. The output grid thus transforms the color information of the input into a spatial pattern of grey pixels.	empty_grid\nget_pixel_coords: To find the coordinates and colors of the non-black pixels.\nfill_value: To fill specific positions in the 3x3 grid with grey pixels.	1. Create a 3x3 empty grid using `empty_grid`.\n2. Use `get_pixel_coords` to identify non-black colored pixels in the input grid.\n3. For each non-black colored pixel, fill the corresponding grey pixels in the new grid:\n   - If the pixel is red, fill the 'T' shape with grey.\n   - If the pixel is blue, fill the '+' shape with grey.\n   - If the pixel is green, fill the mirrored 'L' shape with grey.\n4. Return the 3x3 grid with the filled grey shapes as the final output.
23581191.png	The logic of the problem involves identifying two distinct colored pixels and drawing orthogonal lines (plus signs) that extend across the entire grid from these pixels. Where these lines intersect, the intersection point is highlighted in red.	Important objects: The two distinct colored pixels in the input grid. Changes: Drawing vertical and horizontal lines across the grid using the colored pixels as the center. If the lines intersect, the intersecting pixel is changed to red.	get_pixel_coords(grid): To identify the coordinates of the distinct colored pixels. fill_row(grid, row_num, value): To draw horizontal lines of the plus sign. fill_col(grid, col_num, value): To draw vertical lines of the plus sign. fill_value(grid, pos, value): To color the intersecting point red.	1. Initialize an empty grid with the same dimensions as the input using empty_grid(row, col). 2. Use get_pixel_coords(grid) on the input to find all the coordinates of the uniquely colored pixels. 3. For each unique pixel coordinate found, draw a plus sign:  1. Use fill_row(grid, row_num, value) to draw the horizontal line of the plus sign using the color of the pixel.  2. Use fill_col(grid, col_num, value) to draw the vertical line of the plus sign using the color of the pixel. 4. Check for intersection:  1. If the coordinates of the drawn lines from the two centers overlap at any point, use fill_value(grid, pos, value) to change that pixel to red.
3de23699.png	The main goal is to crop the main object and recolor it according to the color of the surrounding individual pixels.	Identify the main object in the grid. Locate the surrounding individual pixels which share the same colour. Crop the image around the main object. Change the main object's colour to match the surrounding pixels' colour.	get_objects(grid, by_color=True, more_info=True) - to identify objects based on colour and obtain more details such as their size and shape. crop_grid(grid, tl, br) - to crop the main object from the grid. change_object_color(obj, value) - to change the colour of the cropped object.	1. Use get_objects(grid, by_color=True, more_info=True) to identify all coloured objects within the grid and get additional details, such as the size and shape of each object. 2. Identify the individual pixels with a uniform colour surrounding the main object. 3. Use crop_grid(grid, tl, br) to crop the main object out of the grid. 4. Use change_object_color(obj, value) to change the colour of the cropped object to the colour of the surrounding individual pixels.
46442a0e.png	The task involves returning a grid that is 2 times larger in width and height that contains rotated versions of the original pattern. The input grid is copied and rotated 4 times, placed at each corner of the output grid. The top left, top right, bottom right, bottom left pattern are rotated clockwise 0 degrees, 90 degrees, 180 degrees and 20 degrees respectively.	Each color pixel in the input grid is copied and rotated 4 times to the output grid. The rotation transformation for each position would be that the top left, top right, bottom right, bottom left pattern are rotated clockwise 0 degrees, 90 degrees, 180 degrees and 20 degrees respectively.	empty_grid can be used to initialize a output grid that is double in width and height of the input grid. rotate_clockwise can be used to rotate the input grid.  fill_object can be used to fill grid with object.	1. Create a output grid that is double in width and height of the input grid. 2. Fill each corner with a rotated version of the input grid. The rotation for each corner being the top left, top right, bottom right, bottom left pattern are rotated clockwise 0 degrees, 90 degrees, 180 degrees and 20 degrees respectively.
8efcae92.png	The task involves selecting the blue grid that contains the maximum number of red pixels.	The object are the blue portions of the grid.  	get_objects can be used to get the blue grids. get_pixel_coords can be used to get the number of red pixels inside a blue grid.	1. obtain the objects 2. count the number of red pixels in each grid 3. the object with the most number of red pixels forms the output grid.
